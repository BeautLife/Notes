## Note 3

采用面向对象的编程方式：

原因：面向对象的编程方式更符合人类的思维方式



### 类 和 对象

其中

- 类（设计图）：对象共同特征的描述
- 对象：类的具象表现，真实存在的具体东西



#### 类的定义

```
public class ClassName{
  1. 成员变量 - 代表属性，一般是名词
  2. 成员方法 - 代表行为，一般是动词
  3. 构造器
  4. 代码块
  5. 内部类
}
```



#### 类的简单分类

- 用来描述一类事物的类，专业叫做  javabean 类，其特点是没有 main 方法
- 编写 main 方法的类，叫做测试类，一般用于创建 javabean 类对象，并进行使用



#### 创建类的注意事项

- 类的所有单词首字母都应大写，按大驼峰模式定义，并且具有实际意义，见名知义
- 一个 java 文件中可以定义多个 class，并且只有一个使用 public 修饰，并且 public 修饰的类名必须成为代码文件名（**但是实际开发中建议一个文件定义一个 class**）
- 成员变量定义格式： **修饰符 数据类型 变量名 = 初始化值；**，并且**定义时一般无需指定初始化值，存在默认值**，只有创建之后才赋值



#### 类的设计方法

对于类的设计，需要在需求中提炼名词属性，例如，现需设计一个考试管理系统，其中功能包括班级管理，教师管理，学生管理以及试卷管理，那么简单来说至少需要设计四个类，分别用于控制班级，教师，学生和试卷四种对象，对于每个类属性的设计，同样也可以根据出现的名词进行定义。



#### 封装

对象代表什么，就要封装对应的数据，并提供数据对应的行为，例如，在 “人关门” 这样的需求中，关门 这一动作应该被设计在 门  这一对象中 。

封装的方式可以简化代码，降低学习成本，在需要使用的时候，直接找对应的方法即可



#### private 关键字

- private 是一个权限修饰符
- 可以用于修饰成员（包括成员变量和成员方法）
- 被 private 修饰的成员只能在本类中访问（提高数据的安全性）
- 使用 private 修饰的成员变量，如果需要被其他类使用，需要提供相对应的操作
- 提供 “setXxx（参数）”方法，用于给成员变量赋值，使用 public 关键字修饰
- 提供 “getXxx（）”方法，用于获取成员变量的值，使用 public 关键字修饰



#### this 关键字

区分成员变量和局部变量，如果成员变量和局部变量中存在同名现象，那么在使用该变量的时候就会触发 “就近原则”，但是为了保证所有变量名都具有实际意义，因此有的时候会出现成员变量和局部变量重名的现象，此时为了加以区分，在变量前面加 `this.`，即可指代成员变量

实际上 this 关键字代表的是 调用者 的地址，因此对于一个对象，this 代表的就是本身对象的地址，因此在初始化方法中，使用 this.a = a 进行初始化的时候，根据就近原则，a 代表的即是方法形参，this.a = obj.a ，因此是对 对象中的 a 进行赋值



#### 构造方法

在创建对象的时候进行赋值

方法特点：

- 方法名与类名相同，大小写也一致

- 没有返回值类型 `public Person(){...}`

- 没有具体的返回值，因此不能使用 return 

- 在创建构造方法的时候一般会创建两个，一个是空参构造方法，其设置的所有成员变量均为默认值：（如果没有写构造方法，则虚拟机会自动为类创建一个构造方法）

  ```java
  public Person(){
  
  }
  ```

  另一个则是带全部参数的构造方法：

  ```java
  public Person(int age, String gender){
      this.age = age;
      this.gender = gender;
  }
  ```

- 注意 构造方法不能手动调用，只能是在创建的时候使用虚拟机调用

- 注意 如果只写了带有全部参数的构造方法而没有写空参构造方法（则虚拟机不会自动创建构造方法），则在创建对象的时候必须设置全部参数，而不能使用空参构造方法，同时，由于有些类在创建对象的时候并不能确定有多少属性，因此 **实际中空参构造方法和全部参数构造方法都要手动写上（不管用不用）**

注意 构造方法的作用，构造方法只是创建对象过程中的一部分，由 JVM 创建对象的时候自动调用，其作用在于对成员变量进行初始化。



#### 标准 JavaBean 类的创建

要点：

- 类名见名知义
- 成员变量使用 private 关键字修饰
- 提供至少两个构造方法
  - 无参构造方法
  - 全部参数构造方法
- 对每个成员变量创建对应的 setXxx（）方法和 getXxx（）方法



#### 对象内存图

Java 内存分配

- 方法区： HelloWorld.class 等字节码文件加载的时候进入内存 （JDK8 之后将其原本功能归类到 元空间 和 堆 中）
- 栈内存： 方法运行时进入的内存，其中创建的变量也是存储在这里
- 堆内存： 使用 new 关键字创建的内容会在堆中开辟空间并产生地址 

##### 一个对象的内存图

```
Student s = new Student()
```

创建对象过程：

- 在方法区加载 class 字节码文件
- 申明局部变量
- 在 堆 内存中开辟一个空间
- 默认初始化
- 显示初始化
- 构造方法初始化
- 将堆内存中的地址值赋给左边的局部变量

对于类：

```java
public class Student {
    String name;
    int age;

    public void study(){
        System.out.println("...");
    }
}
```

在实际创建对象的时候:

```java
public class TestStudent{  // 将 TestStudent.class 文件加载到方法区 
	public static void main(String[] args){ // 方法 在 栈 中开辟空间
		Student s = new Student();  // 加载 Student.class 文件（方法区）
                                 // new 关键字 在堆 中开辟空间，对于参数的值，有三步：（1）默认初始化，赋默认值（null，0等等），随后显示初始化，如果明确指出某个变量的值，则赋值，（3）根据构造方法进行初始化，这里进行无参构造方法初始化
                                 // 创建之后 s 中保存的是 堆 中的地址
		System.out.println(s)   // 输出的结果为对象 s 在堆中的地址值
	}
                              // main 方法执行完毕后， 整个方法在 栈 中退出，随之变量消失，与之对应的 堆 中的对象也成为垃圾

}
```

对于两个同类对象的创建，.class 文件只需要加载一次即可

对于两个引用指向同一个对象， Student s2 = s1， 那么实际上是 将 s2 指向开始 s1 指向的 堆 中对象的地址，如果使用 s1 = null， 则变量名 与 实际对象的联系就会断开，如果继续使用就会出现 空指针 异常



#### 基本数据类型和引用数据类型

基本数据类型，直接在 栈 中方法内部开辟内存区间进行存储

- 在进行复制的时候，赋值给其他变量也是真实的数值

引用数据类型， 栈 中方法内部的变量存储的是 堆 空间的地址值（引用的含义）

- 数值存储在其他空间，在赋值给其他值的时候，赋值的是地址值，这样一个进行修改，也会影响其他的地方



#### 成员变量和局部变量

注意：

- 成员变量有默认的初始化值，而局部变量则没有默认值，需要在使用之前赋值（否则会报错）
- 两者内存位置不同， 成员变量位于 堆 内存中，局部变量则是在方法创建的时候创建在 栈 内存中的
- 局部变量只在方法的生存周期内存在， 而成员变量则是与整个对象存在的期间内存在



### 项目训练

#### 输出语句

```java
System.out.printf("%s xxxx", "xxx")
```

使用`%s`作为占位符，在后面统一书写，注意 `printf`没有换行功能，所以在换行的时候需要使用 `println`进行换行



#### 键盘录入

几种键盘录入的方式：

- 第一种方式： 这三种方式会以 空格，tab 以及换行结束
  - nextInt() 用于接收一个整数
  - nextDouble() 用于接收一个浮点数
  - next() 接受一个字符串
- 第二种方式：
  - nextLine() 接收一行字符串

两种方式不应混用，例如使用第一种方式结束输入的时候，回车会被 `nextLine()`函数接收，造成不必要的问题，第二种方法一般会搭配格式转换使用













### 其他

#### IDEA 同时选中多行

可以使用 `Alt`同时选中多行，或者使用按住鼠标滚轮拖动，即可同时选中多行代码的同一位置



#### IDEA快速生成构造方法

- `Alt + insert +(Fn)`: 在选择界面中选择 Constructor ，选择最下面的 “Select None” 表示建立无参构造函数，  `Ctrl + A` 选择全部的内容后建立全部参数的构造方法 （或者 右键  菜单中选择 Generate， 然后选择后面的内容）
- 上述方法的选择框中同样有  Setter Getter 和 Setter and Getter 选项， 可以自动生成所有的属性的 set get 方法
- 使用 ptg 插件 （File - Setting - plugins）（这里可能会由于网络原因加载不出来），右键 “ptg to JavaBean” 即可生成构造方法等内容









